üîç LOGIQUE PARSER FFE - D√âTAILL√âE
üìä Structure HTML FFE √† parser
Page R√©sultats FFE (Grille am√©ricaine)
URL type : https://www.echecs.asso.fr/Resultats.aspx?URL=Tournois/Id/68994/68994&Action=Ga
Structure HTML observ√©e :
html<table>
  <thead>
    <tr>
      <th>Pl</th>     <!-- Classement -->
      <th>Nom</th>
      <th>Rapide</th> <!-- Elo -->
      <th>Cat.</th>
      <th>Fede</th>
      <th>Ligue</th>
      <th>R 1</th>    <!-- R√©sultat ronde 1 -->
      <th>R 2</th>
      <th>R 3</th>
      ...
      <th>Pts</th>    <!-- Points totaux -->
      <th>Tr.</th>    <!-- Buchholz -->
      <th>Bu.</th>
      <th>Perf</th>   <!-- Performance -->
    </tr>
  </thead>
  <tbody>
    <!-- Exemple ligne joueur -->
    <tr>
      <td>3</td>                           <!-- Classement: 3 -->
      <td>KIORGWU Jesse</td>               <!-- Nom -->
      <td>1541 F</td>                      <!-- Elo: 1541 -->
      <td>PupM</td>                        <!-- Cat√©gorie -->
      <td><img src="flags/FRA.GIF"></td>
      <td>PAC</td>
      <td>+ 75B</td>                       <!-- R1: Victoire (+) contre 75, Blancs (B) -->
      <td>+ 27N</td>                       <!-- R2: Victoire, Noirs -->
      <td>+ 10B</td>                       <!-- R3: Victoire -->
      <td>- 6N</td>                        <!-- R4: D√©faite (-) -->
      <td>= 2B</td>                        <!-- R5: Nulle (=) -->
      <td>4¬Ω</td>                          <!-- Points: 4.5 -->
      <td>12</td>                          <!-- Buchholz: 12 -->
      <td>16¬Ω</td>                         <!-- Autre Buchholz -->
      <td>1794</td>                        <!-- Performance: 1794 -->
    </tr>
    
    <!-- Ligne avec club diff√©rent (√† ignorer) -->
    <tr>
      <td>9</td>
      <td>ENGLES Simeon</td>
      <td>1462 F</td>
      <td>PupM</td>
      <td><img></td>
      <td>PAC</td>
      <td>+ 13B</td>
      <td>+ 81N</td>
      <td>- 6B</td>
      <td>+ 56N</td>
      <td>+ 31B</td>
      <td>4</td>
      <td>11</td>
      <td>13¬Ω</td>
      <td>1545</td>
    </tr>
  </tbody>
</table>

<!-- IMPORTANT: Liste des joueurs avec CLUB -->
<!-- Existe aussi sur Action=Ls -->
<table>
  <tr>
    <td>3</td>
    <td>KIORGWU Jesse</td>
    <td>1541 F</td>
    <td>PupM</td>
    <td>FRA</td>
    <td>PAC</td>
    <td>Hay Chess</td>  <!-- üéØ CLUB ICI -->
  </tr>
  <tr>
    <td>9</td>
    <td>ENGLES Simeon</td>
    <td>1462 F</td>
    <td>PupM</td>
    <td>FRA</td>
    <td>PAC</td>
    <td>Marseille-Echecs</td>  <!-- Autre club -->
  </tr>
</table>

üîß √âtapes du Parser
√âTAPE 1 : Fetch double page
typescript// Parser besoin de 2 pages FFE :

// 1. Page liste joueurs (Action=Ls) ‚Üí Pour avoir les CLUBS
const urlList = url.replace('Action=Ga', 'Action=Ls');
const htmlList = await fetch(`/api/scrape`, { 
  body: JSON.stringify({ url: urlList }) 
});

// 2. Page r√©sultats (Action=Ga) ‚Üí Pour avoir les R√âSULTATS
const htmlResults = await fetch(`/api/scrape`, { 
  body: JSON.stringify({ url }) 
});
Pourquoi 2 pages ?

Page Ga (r√©sultats) : N'affiche PAS toujours le club
Page Ls (liste) : Affiche le club de chaque joueur
Il faut CROISER les 2 sources


√âTAPE 2 : Parser page liste (Ls) ‚Üí Map joueur:club
typescript// Parse HTML avec Cheerio ou DOMParser
import * as cheerio from 'cheerio';

function parsePlayerClubs(htmlList: string): Map<string, string> {
  const $ = cheerio.load(htmlList);
  const playerClubMap = new Map<string, string>();
  
  // Trouver le tableau liste
  $('table tr').each((i, row) => {
    const cells = $(row).find('td');
    if (cells.length < 7) return; // Skip header
    
    const name = $(cells[1]).text().trim(); // Colonne Nom
    const club = $(cells[6]).text().trim(); // Colonne Club
    
    playerClubMap.set(name, club);
  });
  
  return playerClubMap;
  // R√©sultat: Map {
  //   "KIORGWU Jesse" => "Hay Chess",
  //   "ENGLES Simeon" => "Marseille-Echecs",
  //   ...
  // }
}

√âTAPE 3 : Parser page r√©sultats (Ga) ‚Üí Donn√©es compl√®tes
typescriptinterface RoundResult {
  round: number;
  score: 0 | 0.5 | 1;
  opponent?: string;
  color?: 'B' | 'N'; // Blancs/Noirs
}

interface Player {
  name: string;
  elo: number;
  club: string;
  ranking: number;
  results: RoundResult[];
  totalPoints: number;
  buchholz: number;
  performance: number;
  validated: boolean[];
}

function parseResults(
  htmlResults: string, 
  playerClubMap: Map<string, string>
): Player[] {
  const $ = cheerio.load(htmlResults);
  const players: Player[] = [];
  
  // Trouver le tableau r√©sultats
  const table = $('table').first(); // Premier tableau = grille am√©ricaine
  const headerRow = table.find('thead tr').first();
  
  // 1. D√©tecter le nombre de rondes
  const roundColumns: number[] = [];
  headerRow.find('th').each((i, th) => {
    const text = $(th).text().trim();
    if (text.match(/^R\s*\d+$/)) { // "R 1", "R 2", etc.
      roundColumns.push(i);
    }
  });
  const numRounds = roundColumns.length;
  
  // 2. Trouver les index des colonnes importantes
  let ptsIndex = -1;
  let buchholzIndex = -1;
  let perfIndex = -1;
  
  headerRow.find('th').each((i, th) => {
    const text = $(th).text().trim();
    if (text === 'Pts') ptsIndex = i;
    if (text === 'Tr.' || text === 'Tr') buchholzIndex = i;
    if (text === 'Perf') perfIndex = i;
  });
  
  // 3. Parser chaque ligne joueur
  table.find('tbody tr').each((rowIndex, row) => {
    const cells = $(row).find('td');
    if (cells.length < 5) return; // Skip lignes invalides
    
    // Extraire donn√©es de base
    const ranking = parseInt($(cells[0]).text().trim());
    const nameRaw = $(cells[1]).text().trim();
    const name = cleanPlayerName(nameRaw);
    
    const eloText = $(cells[2]).text().trim();
    const elo = parseElo(eloText); // "1541 F" ‚Üí 1541
    
    // R√©cup√©rer le club depuis la Map
    const club = playerClubMap.get(name) || '';
    
    // üéØ FILTRER: Garder seulement "Hay Chess"
    if (club !== 'Hay Chess') return;
    
    // Parser r√©sultats ronde par ronde
    const results: RoundResult[] = [];
    roundColumns.forEach((colIndex, round) => {
      const cellText = $(cells[colIndex]).text().trim();
      const result = parseRoundResult(cellText, round + 1);
      if (result) results.push(result);
    });
    
    // Extraire stats finales
    const totalPoints = parsePoints($(cells[ptsIndex]).text().trim());
    const buchholz = parseFloat($(cells[buchholzIndex]).text().trim()) || 0;
    const performance = parseInt($(cells[perfIndex]).text().trim()) || 0;
    
    players.push({
      name,
      elo,
      club,
      ranking,
      results,
      totalPoints,
      buchholz,
      performance,
      validated: new Array(numRounds).fill(false) // Init validations
    });
  });
  
  return players;
}

√âTAPE 4 : Parsers utilitaires
typescript// Parser nom joueur (nettoyer caract√®res sp√©ciaux)
function cleanPlayerName(raw: string): string {
  return raw
    .replace(/\s+/g, ' ')  // Multiple espaces ‚Üí 1 espace
    .trim()
    .toUpperCase();         // Uniformiser casse
}

// Parser Elo: "1541 F" ‚Üí 1541
function parseElo(text: string): number {
  const match = text.match(/(\d+)/);
  return match ? parseInt(match[1]) : 0;
}

// Parser points: "4¬Ω" ‚Üí 4.5
function parsePoints(text: string): number {
  text = text.replace('¬Ω', '.5');  // ¬Ω ‚Üí .5
  return parseFloat(text) || 0;
}

// Parser r√©sultat d'une ronde
function parseRoundResult(
  cellText: string, 
  round: number
): RoundResult | null {
  // Format: "+ 75B", "- 6N", "= 2B", "EXE", "> 91B"
  
  if (!cellText || cellText === '-') return null; // Pas jou√©
  
  // Cas sp√©ciaux
  if (cellText === 'EXE' || cellText.startsWith('>')) {
    return { round, score: 1, opponent: 'EXEMPT' };
  }
  
  // Parser r√©sultat normal: [+/-/=] [num√©ro][B/N]
  const match = cellText.match(/^([+\-=])\s*(\d+)([BN])?$/);
  if (!match) return null;
  
  const [_, result, opponentNum, color] = match;
  
  let score: 0 | 0.5 | 1;
  if (result === '+') score = 1;
  else if (result === '-') score = 0;
  else score = 0.5;
  
  return {
    round,
    score,
    opponent: opponentNum,
    color: color as 'B' | 'N' | undefined
  };
}

√âTAPE 5 : Calcul stats club
typescriptinterface ClubStats {
  round: number;
  totalPoints: number;
  numPlayers: number;
  average: number;
}

function calculateClubStats(
  players: Player[], 
  currentRound: number
): ClubStats {
  const numPlayers = players.length;
  
  // Sommer les points de tous les joueurs √† la ronde N
  const totalPoints = players.reduce((sum, player) => {
    // Points cumul√©s jusqu'√† la ronde currentRound
    const pointsUpToRound = player.results
      .filter(r => r.round <= currentRound)
      .reduce((acc, r) => acc + r.score, 0);
    return sum + pointsUpToRound;
  }, 0);
  
  const average = numPlayers > 0 ? totalPoints / numPlayers : 0;
  
  return {
    round: currentRound,
    totalPoints,
    numPlayers,
    average: Math.round(average * 100) / 100 // 2 d√©cimales
  };
}

üéØ D√©tection ronde en cours
typescriptfunction detectCurrentRound(players: Player[]): number {
  // Trouver le max de rondes jou√©es
  let maxRound = 0;
  players.forEach(player => {
    player.results.forEach(result => {
      if (result.round > maxRound) {
        maxRound = result.round;
      }
    });
  });
  return maxRound;
}

üß™ Tests du parser
Test 1 : Parser page simple
typescriptconst testHtml = `
<table>
  <thead>
    <tr><th>Pl</th><th>Nom</th><th>Rapide</th><th>R 1</th><th>Pts</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>3</td>
      <td>BACHKAT Fares</td>
      <td>1468 F</td>
      <td>+ 10B</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
`;

const clubMap = new Map([['BACHKAT Fares', 'Hay Chess']]);
const players = parseResults(testHtml, clubMap);

console.assert(players.length === 1);
console.assert(players[0].name === 'BACHKAT FARES');
console.assert(players[0].elo === 1468);
console.assert(players[0].results[0].score === 1);
Test 2 : Filtrage club
typescriptconst clubMap = new Map([
  ['BACHKAT Fares', 'Hay Chess'],      // ‚úì Garder
  ['ENGLES Simeon', 'Autre Club']       // ‚úó Filtrer
]);

const players = parseResults(testHtml, clubMap);
console.assert(players.length === 1); // Seulement Hay Chess
Test 3 : Points avec demi
typescriptconsole.assert(parsePoints('4¬Ω') === 4.5);
console.assert(parsePoints('2.5') === 2.5);
console.assert(parsePoints('0') === 0);

‚ö†Ô∏è Edge Cases √† g√©rer
1. Joueur avec tiret dans le nom
typescript// "BEN AMAR LAURANS Nael" ‚Üí "BEN AMAR LAURANS NAEL"
// Uniformiser avec toUpperCase
2. Elo estim√© (E) ou provisoire (N)
typescript// "999 E" ‚Üí 999
// "1480 N" ‚Üí 1480
// parseElo() extrait juste le nombre
3. Rondes non jou√©es
typescript// Cellule vide ou "-" ‚Üí null
// Ne pas ajouter au tableau results[]
4. Exempt (bye)
typescript// "EXE" ou "> 91B" ‚Üí { score: 1, opponent: 'EXEMPT' }
5. Ordre colonnes variable
typescript// Ne PAS hardcoder index colonnes !
// D√©tecter dynamiquement avec headerRow
6. Accents dans noms
typescript// "M√úLLER" ‚Üí Garder tel quel
// .toUpperCase() g√®re les accents

üöÄ Optimisations
Cache HTML fetch√©
typescript// √âviter re-fetch si d√©j√† en m√©moire
const htmlCache = new Map<string, { html: string, timestamp: number }>();

async function fetchWithCache(url: string): Promise<string> {
  const cached = htmlCache.get(url);
  const now = Date.now();
  
  // Cache 30 secondes
  if (cached && (now - cached.timestamp) < 30000) {
    return cached.html;
  }
  
  const html = await fetch('/api/scrape', {
    method: 'POST',
    body: JSON.stringify({ url })
  }).then(r => r.json()).then(d => d.html);
  
  htmlCache.set(url, { html, timestamp: now });
  return html;
}
Batch processing
typescript// Si plusieurs tournois, fetcher en parall√®le
const htmlPromises = tournaments.map(t => fetchWithCache(t.url));
const htmlResults = await Promise.all(htmlPromises);
```

---

## üìù R√©sum√© logique compl√®te
```
1. User clique "Refresh" sur onglet tournoi
   ‚Üì
2. Fetch 2 URLs FFE:
   - Action=Ls ‚Üí Map joueur:club
   - Action=Ga ‚Üí R√©sultats complets
   ‚Üì
3. Parser HTML:
   - D√©tecter colonnes dynamiquement
   - Parser chaque ligne joueur
   - Filtrer club = "Hay Chess"
   ‚Üì
4. Calculer:
   - Ronde en cours (max ronde)
   - Stats club (somme points / nb joueurs)
   ‚Üì
5. Merger avec validations localStorage
   ‚Üì
6. Afficher dans PlayerTable

FIN LOGIQUE PARSER
Claude Code a maintenant TOUTE la logique d√©taill√©e pour parser les pages FFE ! üéØ